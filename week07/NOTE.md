学习笔记

1、
__getattribute__

__getattr__

异同：
• 都可以对实例属性进行获取拦截
• __getattr__() 适用于未定义的属性
• __getattribute__()  对所有属性的访问都会调用该方法
底层协议，工作方法，只需要懂得底层原理即可，平常不使用
描述符：实现特定协议的类
property 类需要实现__get__、__set__、__delete__ 方法
属性描述符，  了解描述器原理
把方法封装成属性，默认只有指读的功能。
相应改写实现，写功能；
被修饰的函数使用相同的函数名称。
2、
# 问题1 gene有没有被继承？
p1.gene
继承父类的__init__中super().__init__(name)
# 问题2 People的父类是谁？
新式类默认继承Object
# 问题3 能否实现多重层级继承

# 问题4 能否实现多个父类同时继承

可以，钻石继承，继承顺序的问题：MRO，Subclass.mro显示继承的查找顺序，新式类是广度优先算法搜索继承的查找顺序；经典类是深度优先搜索的查找顺序

3、有向无环图：DAG(Directed Acyclic Graph)，入度为0的节点开始查找

4、python 没有重载功能

5、类的涉及原则，单例模式：
    1、每个类的职责是单一的，爬取或者存储或保存是拆分成三部分，确保每一个类是做单一的一份工作。
    2、扩展是开放的，对修改是封闭的，不应该修改里边的代码，而是增加功能。用@classmethod
    3、继承，子类实现的功能比较完整的覆盖父类的方法
    4、高层不能底层依赖，通过抽象来解耦
    5、接口提供的方法，刚好是我们需要的属性。不需要额外的功能和属性。
6、单例模式
实例多个对象，实质上是相同的，只占用一块内存
对象只存在一个实例
7、__init__ 和 __new__ 的区别：
• __new__ 是实例创建之前被调用，返回该实例对象，是静态方法
• __init__ 是实例对象创建完成后被调用，是实例方法
• __new__ 先被调用，__init__ 后被调用
• __new__ 的返回值（实例）将传递给 __init__ 方法的第一个参数，__init__ 给这个
实例设置相关参数
1、用装饰器实现单实例
8、__new__，singleton多线程时会出现线程安全问题，需要再判断isinstance执行进行加锁。
9、工厂模式/简单工厂模式/静态工厂模式
根据传入参数的不同，创建不同的实例。像工厂的开关一样，软件系统，提供不同外观的按钮，实现不同的形状和形态，继承自一个基类。
三种角色：
工厂角色：负责产生实例，判断你输入的参数
抽象产品角色：基类，创建对象的父类，提供公共的接口Human，名字、性别。
具体产品角色：man,woman，不同的按钮，不同对象的创建，充当角色具体的一个实例。根据传入的参数会有不同的属性。
10、元类，超越原有类，元类是关于类的类，是类的模板。
元类是用来控制如何创建类的，正如类是创建对象的模板一样。
• 元类的实例为类，正如类的实例为对象
是创建类的类，是类的
函数叫可调用对象
元类一般写框架时使用，读懂框架代码即可，自己写代码时不会使用








